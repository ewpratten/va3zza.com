<!DOCTYPE html>
<html lang="en">

<head>
    



    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-KFJ95RP');</script>
    <!-- End Google Tag Manager -->

    

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/jpg" href="https:&#x2F;&#x2F;avatars.githubusercontent.com&#x2F;u&#x2F;21065412" />
    
    <link rel="canonical" href="https:&#x2F;&#x2F;ewpratten.com&#x2F;blog&#x2F;reading-a-bitmap&#x2F;" />
    

    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://ewpratten.com/ rss.xml">
    <link rel="webmention" href="https://webmention.io/ewpratten.com/webmention" />
    <link rel="pingback" href="https://webmention.io/ewpratten.com/xmlrpc" />

    <title>
Reading metadata from a bitmap file
 | Evan Pratten</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Urbanist:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,400;0,700;1,400;1,700&display=swap"
        rel="stylesheet">
    <link rel="preconnect" href="https://maxst.icons8.com">
    <link rel="stylesheet"
        href="https://maxst.icons8.com/vue-static/landings/line-awesome/line-awesome/1.3.0/css/line-awesome.min.css">
    <link rel="stylesheet" href="/styles/layout.css">
    <link rel="stylesheet" href="/styles/project_mosaic.css">


    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css"
        integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />


    <meta name="twitter:card" content="summary" />
    <meta name="og:site" content="ewpratten.com" />
    <meta name="og:image" content="https:&#x2F;&#x2F;avatars.githubusercontent.com&#x2F;u&#x2F;21065412" />
    <meta name="twitter:creator" content="@ewpratten">
    <meta name="og:site_name" content="Evan Pratten (VA3ZZA)" />

    






<meta property="og:title" content="Reading metadata from a bitmap file - Evan Pratten" />
<meta property="og:type" content="article" />

<meta property="og:description" content="A project writeup" />
<meta property="description" content="A project writeup" />

<meta property="article:published_time" content="2020-10-01T00:00:00" />









<script type="application/ld+json">
    
    
    
    {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "url": "https://ewpratten.com/blog/reading-a-bitmap/",
    "headline": "Reading metadata from a bitmap file",
    "dateCreated": "2020-10-01T00:00:00",
    "datePublished": "2020-10-01T00:00:00",
    "dateModified": "2020-10-01T00:00:00",
    "inLanguage": "en-CA",
    "isFamilyFriendly": "true",
    "accountablePerson": {
        "@type": "Person",
        "name": "Evan Pratten",
        "url": "https://ewpratten.com"
    },
    "author": {
        "@type": "Person",
        "name": "Evan Pratten",
        "url": "https://ewpratten.com"
    },
    "creator": {
        "@type": "Person",
        "name": "Evan Pratten",
        "url": "https://ewpratten.com"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Evan Pratten",
        "url": "https://ewpratten.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://avatars.githubusercontent.com/u/21065412",
            "width": "460",
            "height": "460"
        }
    },
    "mainEntityOfPage": "True",
    "keywords": [],
    "genre": [],
    "articleSection": "Blog Post",
    "__articleBody__": "{{content}}"
}
</script>






</head>

<body>
    <div class="container">
        <div class="profile-card">
            
<div class="row">
    <div class="headshot-container">
        <img src="https:&#x2F;&#x2F;avatars.githubusercontent.com&#x2F;u&#x2F;21065412" alt="Headshot" style="height:50px;width:auto;">
    </div>
    <div class="text-container">
        <h1>Evan Pratten</h1>
        <p>
            Software Developer
        </p>
    </div>
</div>

        </div>
        <div class="navigation-bar">
            <hr>
            <p>
                <a href="/">Home</a> |
                <a href="/blog">Blog</a> |
                
                
                
                <a href="/contact">Contact</a>
                
                
                
            </p>
            <hr>
        </div>
        <div class="page-content">
            
<br><br>
<article class="markdown-body">
    
    <h1 style="border:none;margin-bottom:0;padding-bottom:0">Reading metadata from a bitmap file</h1>
    <h3 style="margin-top:0;color:gray;padding-bottom:.3em;border-bottom:1px solid #eaecef;">
        <em>
            <span style="color:rgb(186, 186, 186)">/*</span>
            A project writeup
            <span style="color:rgb(186, 186, 186)">*/</span>
        </em>
    </h3>
    
    <div style="text-align: justify;">
        <p>Recently, @rsninja722 was telling me about <a rel="noopener" target="_blank" href="https://github.com/rsninja722/file2bmp">a project</a> he was working on. The basic idea is that you pass a file into his program, and it generates a bitmap of the binary data. This was inspired by <a href="/post/ef7b3166">an old post of mine</a> where I did the same thing with a horribly written Python script and the library <a rel="noopener" target="_blank" href="https://github.com/python-pillow/Pillow"><code>pillow</code></a>. </p>
<p>Both of us are currently teaching ourselves the <strong>C</strong> programming language. Him, for a break from JavaScript. Me, for no particular reason. As somebody who mostly lives in the world of high-level C-family languages (C++ and Python), learning C has been a challenging, fun, and rewarding experience. I enjoy immersing myself in <em>&quot;the old way of doing things&quot;</em>. This means sitting down with my Father's old <a rel="noopener" target="_blank" href="https://archive.org/search.php?query=external-identifier%3A%22urn%3Aoclc%3Arecord%3A1028045558%22"><em>ANSI Standard C Programmer's Reference</em></a> book, and looking up what I need to know through a good old appendix full of libc headers and their function lists.</p>
<p>While @rsninja722 was working on his project, I found myself using <code>xxd</code> and <code>python3</code> a lot to debug small issues he encountered. This is fairly tedious, so I set out to write myself a tool to help. I have a small GitHub repository called <a rel="noopener" target="_blank" href="https://github.com/Ewpratten/smalltools">smalltools</a> where I keep the source code to a few small programs I write for fun. I added a new tool file to the repo (called <code>bmpinfo</code>) and got to work.</p>
<h2 id="how-does-a-bitmap-work">How does a bitmap work?</h2>
<p>This was the first big question. I had learned a while ago when working on another project that the image data stored in a bitmap is just raw pixel values, but aside from that, I had no clue how this file format works. Luckily, Wikipedia came to the rescue (as per usual) with <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/BMP_file_format">this great article</a>. It turns out that the file metadata, like the pixel values, is stupidly simple to work with**<sup>1, 2</sup>**. </p>
<div style="color:gray;" markdown="1">
<p><em><strong>1.</strong> I am going to cover only images with <code>24-bit</code> color, with no compression</em><br>
<em><strong>2.</strong> All integers in a bitmap are little-<a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Endianness">endian</a>. These must be converted to the host's endianness</em></p>
</div>
<p>A simple bitmap file consists of only three parts (although the specification can support more data):</p>
<ol>
<li>A file header</li>
<li>File information / metadata</li>
<li>Pixel data</li>
</ol>
<p>I will cover each individually.</p>
<h3 id="the-file-header">The file header</h3>
<p>Like any other standard binary file format, bitmaps start with a file header. This is a block of data that tells programs what this file is, and how it works. The bitmap file header starts with two characters that tell programs what type of bitmap this is. I have only worked with <strong>BM</strong> type files, but the following are all possible file types:</p>
<table><thead><tr><th>Identifier</th><th>Type</th></tr></thead><tbody>
<tr><td><strong>BM</strong></td><td>Windows 3.1x, 95, NT, ... etc.</td></tr>
<tr><td><strong>BA</strong></td><td>OS/2 struct bitmap array</td></tr>
<tr><td><strong>CI</strong></td><td>OS/2 struct color icon</td></tr>
<tr><td><strong>CP</strong></td><td>OS/2 const color pointer</td></tr>
<tr><td><strong>IC</strong></td><td>OS/2 struct icon</td></tr>
<tr><td><strong>PT</strong></td><td>OS/2 pointer</td></tr>
</tbody></table>
<p>The rest of the data is fairly standard. Since I am working in <strong>C</strong>, I have defined this data as a <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)"><code>struct</code></a>. Here is the header:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">typedef struct </span><span>{
</span><span>    </span><span style="color:#65737e;">// File signature
</span><span>    </span><span style="color:#b48ead;">char</span><span> signature[</span><span style="color:#d08770;">2</span><span>];
</span><span>
</span><span>    </span><span style="color:#65737e;">// File size
</span><span>    uint32_t size;
</span><span>
</span><span>    </span><span style="color:#65737e;">// Reserved data
</span><span>    uint16_t reservedA;
</span><span>    uint16_t reservedB;
</span><span>
</span><span>    </span><span style="color:#65737e;">// Location of the first pixel
</span><span>    uint32_t data_offset;
</span><span>} header_t;
</span></code></pre>
<h3 id="bitmap-information-header">Bitmap Information Header</h3>
<p>The <em>Bitmap Information Header</em> (also called <strong>DIB</strong>) contains more information about the file, and can vary in size based on the program that created it. As mentioned earlier, I will only cover the simplest implementation. Due to the possibility of multiple DIB formats, the first element of the header is its own size in bytes. This way, any program can handle any size of DIB without needing to actually implement every header tpe.</p>
<p>Like the file header, I have also written this as a <code>struct</code>.</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">typedef struct </span><span>{
</span><span>    </span><span style="color:#65737e;">// Size of self
</span><span>    uint32_t size;
</span><span>
</span><span>    </span><span style="color:#65737e;">// Image dimensions in pixels
</span><span>    int32_t width;
</span><span>    int32_t height;
</span><span>
</span><span>    </span><span style="color:#65737e;">// Image settings
</span><span>    uint16_t color_planes;
</span><span>    uint16_t color_depth;
</span><span>    uint32_t compression;
</span><span>    uint32_t raw_size; </span><span style="color:#65737e;">// This is generally unused
</span><span>
</span><span>    </span><span style="color:#65737e;">// Resolution in pixels per metre
</span><span>    int32_t horizontal_ppm;
</span><span>    int32_t vertical_ppm;
</span><span>
</span><span>    </span><span style="color:#65737e;">// Other settings
</span><span>    uint32_t color_table;
</span><span>    uint32_t important_colors;
</span><span>} info_t;
</span></code></pre>
<p>Some notes about the data in this header:</p>
<ul>
<li>Image dimensions are <strong>signed</strong> integers. Using a negative size will cause image data to be read right-to-left and bottom-to-top</li>
<li>A setting is present for the pixel density of the image. This is measured in pixels-per-metre (usually <code>3780</code>)</li>
<li>The <code>color_table</code> is the number of colors used in the palette. This defaults to <code>0</code> (meaning <em>all</em>)</li>
<li>The <code>important_colors</code> is the number of colors that are important in the image. This defaults to <code>0</code> (meaning <em>all</em>) and is almost never used </li>
</ul>
<h3 id="pixel-data">Pixel data</h3>
<p>After the file headers comes the pixel data. This is written pixel-by-pixel, and is stored as 3 bytes in the format <code>BBGGRR</code> (little-endian, remember?).</p>
<h2 id="loading-a-bitmap-file-into-a-c-program">Loading a bitmap file into a C program</h2>
<p>For simplicity, I am going to write this for a computer that is based on a little-endian architecture. In reality, most computers are big-endian, and require that you <a rel="noopener" target="_blank" href="https://codereview.stackexchange.com/a/151070">reverse the endian</a> of everything read in.</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">stdlib.h</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">stdio.h</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">stdint.h</span><span>&gt;
</span><span>
</span><span style="color:#65737e;">// Headers defined above
</span><span style="color:#b48ead;">extern struct </span><span>header_t;
</span><span style="color:#b48ead;">extern struct </span><span>info_t;
</span><span>
</span><span style="color:#b48ead;">typedef struct </span><span>{
</span><span>    uint8_t blue;
</span><span>    uint8_t green;
</span><span>    uint8_t red;
</span><span>} pixel_t;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#65737e;">// Read a bitmap
</span><span>    FILE* p_bmp = </span><span style="color:#96b5b4;">fopen</span><span>(&quot;</span><span style="color:#a3be8c;">myfile.bmp</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">rb</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#65737e;">// Create header and info data
</span><span>    header_t header;
</span><span>    info_t info;
</span><span>
</span><span>    </span><span style="color:#65737e;">// Read from the file.
</span><span>    </span><span style="color:#65737e;">// Some compilers will pad structs, so I have 
</span><span>    </span><span style="color:#65737e;">// manually entered their sizes (14, and 40 bytes)
</span><span>    </span><span style="color:#96b5b4;">fread</span><span>(&amp;header, </span><span style="color:#d08770;">14</span><span>, </span><span style="color:#d08770;">1</span><span>, p_bmp);
</span><span>    </span><span style="color:#96b5b4;">fread</span><span>(&amp;info, </span><span style="color:#d08770;">40</span><span>, </span><span style="color:#d08770;">1</span><span>, p_bmp);
</span><span>
</span><span>    </span><span style="color:#65737e;">// Read every pixel
</span><span>    </span><span style="color:#b48ead;">while</span><span>(</span><span style="color:#d08770;">1</span><span>){
</span><span>        pixel_t pixel;
</span><span>        </span><span style="color:#b48ead;">if</span><span>(</span><span style="color:#96b5b4;">fread</span><span>(&amp;pixel, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">1</span><span>, p_bmp) == </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#b48ead;">break</span><span>;
</span><span>
</span><span>        </span><span style="color:#65737e;">// Do something with the pixel
</span><span>        </span><span style="color:#65737e;">// ...
</span><span>    }
</span><span>
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<h2 id="and-thats-it">And thats it!</h2>
<p>Reading bitmap data is really quite simple. Of course, there are many sub-standards and formats that require more code, and sometimes decompression algorithms, but this is just an overview.</p>
<p>If you would like to see the small library I built for myself for doing this, take a look <a rel="noopener" target="_blank" href="https://github.com/Ewpratten/smalltools/tree/master/utils/img">here</a>. (it includes endianness handling)</p>

    </div>

    
    
    <br>
    <hr>
    <script src="https://utteranc.es/client.js" repo="ewpratten/va3zza.com" issue-term="title" label="comment"
        theme="github-light" crossorigin="anonymous" async>
        </script>
    

</article>




        </div>

        <div id="footer">
            <p class="gray">-- EOF --</p>
            <p>
                <em>
                    <a href="https://github.com/ewpratten/va3zza.com"><i class="lab la-github"></i></a>
                    <a href="https://status.ewpratten.com"><i class="las la-info-circle"></i></a>
                    <a href="/rss.xml"><i class="las la-rss"></i></a><br>

                    Thanks for reading :)<br>
                    Site design & content by: <a href="/info">Evan Pratten</a><br>
                    Consider <a href="/donate" target="_blank">supporting my work</a> if you like what you see<br>

                </em>
            </p>
        </div>
    </div>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5912H4H03P"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-5912H4H03P');
    </script>

    <script>
        if (window.performance && performance.getEntriesByType) { // avoid error in Safari 10, IE9- and other old browsers
            let navTiming = performance.getEntriesByType('navigation')
            if (navTiming.length > 0) { // still not supported as of Safari 14...
                let serverTiming = navTiming[0].serverTiming
                if (serverTiming && serverTiming.length > 0) {
                    for (let i = 0; i < serverTiming.length; i++) {
                        if (serverTiming[i].name == 'source') {
                            if (serverTiming[i].description == 'net44') {
                                document.getElementById('ampr-notice').style.display = 'block';
                            }
                        }
                    }
                }
            }
        }
    </script>

    
    <script>
        if (window.location.hostname == 'retrylife.ca') {
            window.location.href = window.location.href.replace('retrylife.ca', 'ewpratten.com');
        }
    </script>

    
    <a rel="me" href="https://social.ewpratten.com/@evan" style="display:none;"></a>
</body>

</html>